[{"content":"For my first post on this blog I decided to create an animation using the animation package. To give this animation some purpose let me demonstrate how kernel density estimators work with the help of an animation.\nIn general, kernel density estimators are, as is kind of obvious by the name, used to estimate the underlying density of a random sample. For instance, imagine that we have a sample drawn from an some unknown distribution.\n1 2  n \u0026lt;- 100 sample \u0026lt;- rexp(n)   Then, assuming that we do not actually know that the current sample was drawn from an exponential distribution, we might want to estimate the density and see if the estimate fits to some well-known parametric family of distributions. With the help of ggplot() and geom_density() this is straightforward.\n1 2 3  library(tidyverse) ggplot() + geom_density(aes(x = sample))   The underlying procedure to generate the plot it to use a kernel density estimator \\(\\hat{f}_h\\) in order to estimate the true underlying density \\(f\\) by using the formula $$ \\hat{f}_h(x) = \\frac{1}{nh} \\sum_{k = 1}^{n} K\\Big(\\frac{x - x_k}{h}\\Big) $$ for all \\(x \\in \\mathbb{R}\\) where \\(n\\) is the sample lengh and \\(h \u0026gt; 0\\) is a smoothing parameter that needs to be chosen and \\(K\\) is a \u0026ldquo;suitable\u0026rdquo; function. Usually, this parameter \\(h\\) is called bandwidth and \\(K\\) is called a kernel function which is often to be the density of a probability distribution.\nThe Bandwidth In geom_density(), the default kernel function is the Gaussian density and the bandwidth can be tweaked through the bw argument.\n1 2 3 4 5 6 7 8 9  h \u0026lt;- 1 ggplot() + geom_density(aes(x = sample), bw = h) + annotate( \u0026#34;label\u0026#34;, x = 0.5, y = 0.1, label = glue::glue(\u0026#34;bw = {h}\u0026#34;) )   Of course, I could now create multiple plots and change the value if h each time to demonstrate the effect of the bandwidth but the point of this post was to create an animation. So let\u0026rsquo;s do that instead.\nNevertheless, to create an animation, we need to be able to create multiple plots. Therefore, let us use the previous code and wrap a function depending on h around that. This function will be our plot generator depending on the bandwidth.\n1 2 3 4 5 6 7 8 9 10 11 12  plot_gen \u0026lt;- function(h) { g \u0026lt;- ggplot() + geom_density(aes(x = sample), bw = h) + annotate( \u0026#34;label\u0026#34;, x = 0.5, y = 0.1, label = glue::glue(\u0026#34;bw = {h}\u0026#34;) ) print(g) # For the animation we need this to be printed }   Now that we have that, define a function that creates all the plots we want to see in our animation, i.e. we create the animation frame by frame. This function can then be passed to saveGIF() from the animation package which then renders the animation for us. Creating a gif in R is as simple as that.\n1 2 3 4 5 6 7  all_the_plots \u0026lt;- function() { map(seq(0.05, 0.5, 0.05), plot_gen) } library(animation) saveGIF(all_the_plots()) ## Output at: animation.gif ## [1] TRUE   As you can see, the bandwidth really is a smoothing parameter. Of course, too much smoothing may not yield great results so the parameter needs to be chosen with care but let us not worry about this in this blog post.\nThe Actual Estimation Procedure Let us create another animation to visualize how kernel density estimation works on a more basic level, i.e. . In order to do so, notice that if the kernel \\(K\\) is a continuous density function of a random variable \\(X\\) (e.g. a Gaussian random variable), then the density function of the random variable \\((X + x_0)h\\) where \\(x_0 \\in \\mathbb{R}\\) and \\(h \u0026gt; 0\\) is given by \\(K((X - x_0)/h)/h.\\)\nConsequently, in the case of standard Gaussian random variables \\(X\\), the kernel density estimator is nothing but the average of the densities of \\(n\\) Gaussian random variables with individual means \\(x_k\\), \\(k = 1, \\ldots, n,\\) and common standard deviation \\(h.\\)\nTherefore, for a given sample you can run a kernel density estimation by taking the following steps:\n Check where each data point \\(x_k\\) is located on the x-axis For each data point \\(x_k\\) draw a Gaussian density \\(f_k\\) with standard deviation \\(h\\) and mean \\(x_k\\) For each \\(x \\in \\mathbb{R}\\) check what are the values of \\(f_k\\), \\(k = 1, \\ldots, n,\\) at \\(x\\) and average these.  So to create a visualization of the kernel density estimation principle, we simple create a function that plots each of those steps for us. Finally, we execute all of these functions and send them to saveGIF().\nWe begin by computing the data we need to create the plots later on, i.e. we simulate a sample and compute the values of the densities.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  compute_density \u0026lt;- function(x_0, h, K = dnorm) { xx \u0026lt;- seq(-6, 6, 0.001) * h tibble( x = xx, density = K((x - x_0) / h) / h ) } set.seed(123) # For the sake of demonstration we use a  # small uniformly distributed sample here x_sample \u0026lt;- runif(5, -5, 5) h \u0026lt;- 1 tib \u0026lt;- tibble( k = seq_along(x_sample), density = map(x_sample, compute_density, h = h) ) %\u0026gt;% unnest(density)   Then, it becomes time for our first step, i.e. check where the sample values are located.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  draw_axis \u0026lt;- function(x_sample, tib) { labs \u0026lt;- glue::glue(\u0026#34;$x_{seq_along(x_sample)}$\u0026#34;) labs \u0026lt;- latex2exp::TeX(labs) p \u0026lt;- ggplot(data = NULL, aes(x = x_sample)) + theme_minimal() + theme( axis.line.x = element_line(), panel.grid = element_blank(), axis.ticks = element_line(size = 1), axis.text = element_text(size = 14) ) + scale_x_continuous( limits = c(min(tib$x), max(tib$x)), breaks = sort(x_sample), minor_breaks = NULL, labels = labs ) + scale_y_continuous( breaks = NULL, limits = c(0, max(tib$density) + 0.025) ) + labs(x = element_blank()) p } p \u0026lt;- draw_axis(x_sample, tib) p   Once we have that, we draw the kernels.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  draw_kernel \u0026lt;- function(p, tib) { p \u0026lt;- p + geom_line(data = tib, aes(x, density, group = k), size = 1) + geom_segment( aes( x = x_sample, xend = x_sample, y = 0, yend = dnorm(0) ), linetype = 2 ) + labs(y = element_blank()) p } draw_kernel(p, tib)   Next, average the densities at an arbitrary position \\(x_0.\\) If we can do that, then we can iterate through different values of \\(x_0.\\)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65  plot_until_x0 \u0026lt;- function(tib, x0) { labs \u0026lt;- glue::glue(\u0026#34;$x_{seq_along(x_sample)}$\u0026#34;) labs \u0026lt;- latex2exp::TeX(labs) tib_x0 \u0026lt;- tib %\u0026gt;% filter(x \u0026lt;= x0) %\u0026gt;% group_by(x) %\u0026gt;% summarise(est = mean(density), .groups = \u0026#34;drop\u0026#34;) anim_col \u0026lt;- \u0026#39;firebrick3\u0026#39; g \u0026lt;- ggplot() + geom_line( data = tib, aes(x, density, group = k), alpha = 0.5, size = 1 ) + geom_point( data = filter(tib, x == x0), aes(x, density), #col = anim_col, alpha = 0.75, size = 3 ) + geom_vline(xintercept = x0, col = anim_col, alpha = 0.5) + geom_point( data = slice_tail(tib_x0, n = 1), aes(x, est), col = anim_col, size = 3 ) + geom_line( data = tib_x0, aes(x, est), col = anim_col, size = 1 ) + theme_classic() + theme( axis.line.x = element_line(), axis.line.y = element_blank(), panel.grid = element_blank(), axis.ticks = element_line(size = 1), axis.text = element_text(size = 14) ) + scale_x_continuous( limits = c(min(tib$x), max(tib$x)), breaks = sort(x_sample), minor_breaks = NULL, labels = labs ) + scale_y_continuous( breaks = NULL, limits = c(0, max(tib$density) + 0.025) ) + labs(x = element_blank(), y = element_blank()) print(g) } x0 \u0026lt;- (0) plot_until_x0(tib, x0)   Last but not least, we may want to display the estimated density without the underlying kernels.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  final_plot \u0026lt;- function(tib) { labs \u0026lt;- glue::glue(\u0026#34;$x_{seq_along(x_sample)}$\u0026#34;) labs \u0026lt;- latex2exp::TeX(labs) tib_x0 \u0026lt;- tib %\u0026gt;% group_by(x) %\u0026gt;% summarise(est = mean(density), .groups = \u0026#34;drop\u0026#34;) anim_col \u0026lt;- \u0026#39;firebrick3\u0026#39; g \u0026lt;- tib_x0 %\u0026gt;% ggplot() + geom_line( aes(x, est), col = anim_col, size = 1 ) + theme_classic() + theme( axis.line.x = element_line(), axis.line.y = element_blank(), panel.grid = element_blank(), axis.ticks = element_line(size = 1), axis.text = element_text(size = 14) ) + scale_x_continuous( limits = c(min(tib$x), max(tib$x)), breaks = sort(x_sample), minor_breaks = NULL, labels = labs ) + scale_y_continuous( breaks = NULL, limits = c(0, max(tib$density) + 0.025) ) + labs(x = element_blank(), y = element_blank()) print(g) } final_plot(tib)   Finally, we have all the ingredients to create the animation by collecting all of these functions in a wrapper function and using it in conjunction with saveGIF().\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  gif \u0026lt;- function(x_sample, tib) { p \u0026lt;- draw_axis(x_sample, tib) map(1:3, ~print(p)) p \u0026lt;- draw_kernel(p, tib) map(1:5, ~print(p)) map(seq(min(tib$x), max(tib$x), 0.5), ~plot_until_x0(tib, .)) map(1:15, ~final_plot(tib)) } saveGIF(gif(x_sample, tib), interval = 0.4, # animation speed ani.width = 720, ani.height = 405, movie.name = \u0026#34;kernelAnimation.gif\u0026#34;)   Thus, we have created a short animation that illustrates the kernel density estimation procedure. Probably, there is some room for improving the animation by fine tuning the plots, tweaking with the animation speed or the number of frames. For now, though, let us leave everything as it is.\nBut feel free to let me know what could be improved in the comments. Similarly, if you want to leave any other form of feedback, feel free to roam the comment section too. Finally, if you enjoyed what you have seen here but do not want to bother writing a comment, you may simply hit the applause button instead.\n","description":"For my first post I create an animation using the animate package.","id":0,"section":"post","tags":["statistics","visualization"],"title":"Animating kernel density estimators","uri":"https://albert-rapp.de/post/visualize-kernel-density-estimation/"},{"content":"Welcome! My Name is Albert Rapp and I am currently a PhD student in mathematics at Ulm University. As part of my obligations as a PhD student I had to teach an applied course on statistical techniques using the statistical software R. Interestingly, I noticed that I actually enjoy using R which is why I went the extra mile and decided to write a set of lecture notes on my own and made them accessible online. In fact, I realized that the process of writing felt (mostly) fun and my retention rate of the stuff I had to learn in order to write about it was actually quite high.\nConsequently, I decided to make a habit out of writing about things I encounter in statistics and/or R. So, what you see here in this blog is the result of that decision. In the end, this is nothing but a personal project and is as much about helping me retain stuff as I learn new things as it is about making a contribution to the R community along the lines of many other blogs and tutorials that helped me learn R. Hopefully, what can be found here will be of benefit to someone other than me.\nCurrently, I aim at posting a new blog entry on a biweekly schedule and regarding the content I will write about whatever I find most interesting at that time. On a long term basis though, I want to cover parts of my R/statistics bucket list which I described in the final chapter of my YARDS lecture notes. If you want to be notified when there is a new post online, you may want to check out the RSS feed which you can access via the RSS symbol at the bottom of the \u0026ldquo;Posts\u0026rdquo; Page.\nThis blog is build with blogdown and Hugo and all blog posts are released under a CC-BY-NC 4.0 license.\n","description":"About Me","id":1,"section":"","tags":null,"title":"About","uri":"https://albert-rapp.de/about/"}]